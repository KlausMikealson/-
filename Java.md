## static:
 - 静态变量：类加载时就会初始化，不依赖任何对象
 - 静态方法：类加载时就会存在，不依赖任何对象
 - 静态代码块：类加载完成后就执行
 - 父类静态代码块->子类静态代码块->父类非静态代码块->父类构造方法->子类非静态代码块->子类构造方法

## final:
 - 修饰变量：类加载时完成初始化
 - 修饰类：不能被继承
 - 修饰方法：不能被继承修改


## 类加载过程：
1.加载：把 .class 文件加载近 JVM，生成 class 对象：
 - 通过类的全限定名来获取定义此类的二进制字节流
 - 将字节流代表的静态存储结构转化为方法区的运行时数据结构
 - 在堆中生成代表这个类的class对象，作为方法区这些数据结构的访问入口
2.验证：检查 .class 文件是否符合 JVM 规范，确保字节码是安全的，验证是可以禁用的
 - 文件格式的验证
 - 元数据验证
 - 字节码验证
 - 符号引用验证
3.准备：初始化类静态变量（设为对应类型的默认初始值），初始化常量
4.解析：将符号引用替换为直接引用
5.初始化：类静态变量初始化，执行构造器，如果 JVM 内存中没有它的父类，则自上而下加载。

## 类加载器的三个机制：
 - 委托：加载类时请求交给父类加载器，父类加载器不能完成则子类加载，否则，继续向上请求
 - 可见性：子类能看到父类加载的类，父类看不到子类的
 - 单一性：一个类仅被加载一次
 
### RPC 步骤：
1. 执行客户端调用语句，传递参数
2. 调用本地系统发送网络消息
3. 消息传到远程主机
4. 远程服务器得到消息并取得参数
5. 服务器根据请求调用以及参数执行远程过程
6. 远程过程执行完毕，将结果返回服务器句柄
7. 服务器句柄返回结果，调用网络服务发送结果
8. 消息传回本机
9. 客户端句柄由网络服务接收消息
10. 客户端接收到结果数据

### JVM体系结构：
 - 指令集：JVM指令集
 - 类加载器
 - 执行引擎
 - 运行时数据区
 - 本地方法区
 
### JVM内存区域：
 - 程序计数器：
    - 线程私有
    - 如果线程正在执行Java方法，记录的是正在执行的字节码指令的地址，如果在执行本地方法，值为0
    - 唯一没有OOM的内训区域
 - 栈：
    - 线程私有，与线程的生命周期相同
    - StackOverFlow、OOM异常
 - 堆：
    - 应用程序在运行时所有对象实例和数组存放的位置，线程共享
    - 可以处于物理上不连续，逻辑上连续的内存空间，可固定大小，也可动态扩展
    - OOM
 - 方法区：
    - 线程共享
    - 存储常量、静态变量
    - 可以处于物理上不连续，逻辑上连续的内存空间，可固定大小，也可动态扩展
    - OOM
 - 运行时常量池：
    - 方法区的一部分，存放字节码文件中的常量池、直接引用、符号引用
    - OOM
 
### 类初始化的时机：
 - 创建类的实例
 - 访问类的静态变量（除常量，因为常量是特殊的变量，编译器把他们当做值(value)而不是域(filed)）
 - 访问类的静态方法
 - 反射
 - 初始化一个类时，发现其父类还未初始化
 - JVM启动时，定义了 main() 的类
 - 接口的初始化比较特殊，只有在真正用到父接口的时候才会初始化父接口
 - 子类调用父类的静态变量，子类不会被初始化，只有父类被初始化
 - 通过数组定义来引用类，不会出发初始化
 - 访问类的常量，不会初始化类

### 四种引用：
 - 强引用：只要一个对象具有强引用，就不会被回收。Object obj = new Object();
 - 软引用：有用但是非必需的对象，如果内存空间不足，就会被回收。
 - 弱引用：非必需对象，不管内存空间是否足够，都回收。
 - 虚引用：无法通过虚引用得到对象，主要用于跟踪对象被垃圾回收器回收的活动，虚引用必须和引用队列联合使用，当垃圾回收器准备回收一个对象时，如果发现他还有虚引用，就会在回收对象之前，把虚引用加入到与之关联的引用队列中
 
### GC算法：
 - 标记清除：
   > 造成大量内存碎片
 - 复制：
   > 内存缩短一半
 - 标记整理：
   > 不产生碎片
   > 耗时
 - 分代收集：复制、标记清除、标记整理
 
### 垃圾收集器：
 
 
### 类加载器：
 - 启动类加载器：C++实现，负责加载JVM基础核心库
 - 扩展类加载器：将java.ext.dirs系统属性所指定目录下的类库加载到JVM
 - 系统类加载器：将用户目录下的类库加载到JVM
 - 用户自定义类加载器：java.lang.ClassLoader的子类








